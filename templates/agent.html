<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Email - Assistant Simple</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .chat-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            width: 90%;
            max-width: 600px;
            height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 20px 20px 0 0;
            text-align: center;
        }
        .chat-header h1 { font-size: 1.5em; margin-bottom: 5px; }
        .chat-header p { font-size: 0.9em; opacity: 0.9; }
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
        }
        .message {
            margin-bottom: 15px;
            animation: slideIn 0.3s ease;
        }
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .message.agent {
            display: flex;
            gap: 10px;
        }
        .message.user {
            display: flex;
            gap: 10px;
            flex-direction: row-reverse;
        }
        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            flex-shrink: 0;
        }
        .message.agent .avatar { background: #667eea; }
        .message.user .avatar { background: #10b981; }
        .bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 15px;
            word-wrap: break-word;
        }
        .message.agent .bubble {
            background: white;
            border: 1px solid #e0e0e0;
        }
        .message.user .bubble {
            background: #667eea;
            color: white;
        }
        .chat-input {
            padding: 20px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
        }
        .chat-input input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 25px;
            font-size: 1em;
            outline: none;
        }
        .chat-input input:focus {
            border-color: #667eea;
        }
        .chat-input button {
            width: 50px;
            height: 50px;
            border: none;
            background: #667eea;
            color: white;
            border-radius: 50%;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s;
        }
        .chat-input button:hover {
            background: #764ba2;
            transform: scale(1.1);
        }
        .quick-actions {
            padding: 10px 20px;
            display: flex;
            gap: 10px;
            overflow-x: auto;
            border-top: 1px solid #e0e0e0;
        }
        .quick-btn {
            padding: 8px 16px;
            background: white;
            border: 2px solid #667eea;
            color: #667eea;
            border-radius: 20px;
            cursor: pointer;
            white-space: nowrap;
            font-size: 0.9em;
            transition: all 0.3s;
        }
        .quick-btn:hover {
            background: #667eea;
            color: white;
        }
        .typing {
            display: flex;
            gap: 5px;
            padding: 10px;
        }
        .typing span {
            width: 8px;
            height: 8px;
            background: #667eea;
            border-radius: 50%;
            animation: bounce 1.4s infinite;
        }
        .typing span:nth-child(2) { animation-delay: 0.2s; }
        .typing span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes bounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <h1>ü§ñ Agent Email</h1>
            <p>Votre assistant pour g√©rer vos emails</p>
        </div>
        
        <div class="chat-messages" id="messages">
            <div class="message agent">
                <div class="avatar">ü§ñ</div>
                <div class="bubble">
                    Bonjour ! Je suis votre agent email.<br><br>
                    Pour commencer, j'ai besoin de 3 informations :<br>
                    1Ô∏è‚É£ Votre email<br>
                    2Ô∏è‚É£ Votre mot de passe d'application<br>
                    3Ô∏è‚É£ Un mot de passe pour s√©curiser<br><br>
                    Commen√ßons : <b>Quel est votre email ?</b>
                </div>
            </div>
        </div>

        <div class="quick-actions" id="quickActions">
            <button class="quick-btn" onclick="quickAction('Envoyer un email')">üìß Envoyer email</button>
            <button class="quick-btn" onclick="document.getElementById('audioUpload').click()">üé§ Audio</button>
            <button class="quick-btn" onclick="document.getElementById('docUpload').click()">üìÑ Document</button>
            <button class="quick-btn" onclick="quickAction('Aide')">‚ùì Aide</button>
        </div>
        
        <input type="file" id="audioUpload" accept="audio/*,.mp3,.wav,.m4a,.ogg,.webm" style="display:none" onchange="uploadAudio(this)">
        <input type="file" id="docUpload" accept=".txt,.pdf,.docx,.doc" style="display:none" onchange="uploadDocument(this)">

        <div class="chat-input">
            <button id="micBtn" onclick="toggleRecording()" style="width: 50px; height: 50px; border: none; background: #10b981; color: white; border-radius: 50%; font-size: 1.2em; cursor: pointer; margin-right: 10px;">üé§</button>
            <input type="text" id="userInput" placeholder="Tapez ou parlez..." onkeypress="if(event.key==='Enter') sendMessage()">
            <button onclick="sendMessage()">‚û§</button>
        </div>
    </div>

    <script>
        let step = 'email';
        let config = {};

        function addMessage(text, isUser = false) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'agent'}`;
            messageDiv.innerHTML = `
                <div class="avatar">${isUser ? 'üë§' : 'ü§ñ'}</div>
                <div class="bubble">${text}</div>
            `;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function showTyping() {
            const messagesDiv = document.getElementById('messages');
            const typingDiv = document.createElement('div');
            typingDiv.className = 'message agent';
            typingDiv.id = 'typing';
            typingDiv.innerHTML = `
                <div class="avatar">ü§ñ</div>
                <div class="bubble">
                    <div class="typing">
                        <span></span><span></span><span></span>
                    </div>
                </div>
            `;
            messagesDiv.appendChild(typingDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function hideTyping() {
            const typing = document.getElementById('typing');
            if (typing) typing.remove();
        }

        async function sendMessage() {
            const input = document.getElementById('userInput');
            const message = input.value.trim();
            if (!message) return;

            addMessage(message, true);
            input.value = '';

            showTyping();
            await new Promise(resolve => setTimeout(resolve, 1000));
            hideTyping();

            if (step === 'email') {
                config.email = message;
                addMessage(`Parfait ! Maintenant, j'ai besoin de votre <b>mot de passe d'application</b>.<br><br>
                    üìå <a href="https://account.microsoft.com/security" target="_blank" style="color: #667eea;">Cr√©ez-le ici pour Hotmail/Outlook</a><br>
                    üìå <a href="https://myaccount.google.com/apppasswords" target="_blank" style="color: #667eea;">Cr√©ez-le ici pour Gmail</a>`);
                step = 'appPassword';
            }
            else if (step === 'appPassword') {
                config.appPassword = message;
                addMessage(`Super ! Derni√®re √©tape : choisissez un <b>mot de passe de s√©curit√©</b> (minimum 8 caract√®res).<br><br>
                    Ce mot de passe prot√®ge vos donn√©es. Vous ne le saisirez qu'une seule fois !`);
                step = 'masterPassword';
            }
            else if (step === 'masterPassword') {
                if (message.length < 8) {
                    addMessage(`‚ùå Le mot de passe doit contenir au moins 8 caract√®res. R√©essayez :`);
                    return;
                }
                config.masterPassword = message;
                await saveConfig();
            }
            else if (step === 'ready') {
                await handleCommand(message);
            }
        }

        async function saveConfig() {
            showTyping();
            try {
                const response = await fetch('/api/save-gmail', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        email: config.email,
                        app_password: config.appPassword,
                        master_password: config.masterPassword
                    })
                });

                const data = await response.json();
                hideTyping();

                if (data.success) {
                    // Sauvegarder en session
                    await fetch('/api/verify-password', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            master_password: config.masterPassword,
                            remember: true
                        })
                    });

                    addMessage(`‚úÖ <b>Configuration termin√©e !</b><br><br>
                        Votre email est configur√© et s√©curis√©. Vous n'aurez plus besoin de ressaisir vos mots de passe.<br><br>
                        Que voulez-vous faire ?<br>
                        ‚Ä¢ "Envoyer un email"<br>
                        ‚Ä¢ "Envoyer un test"<br>
                        ‚Ä¢ "Aide"`);
                    step = 'ready';
                } else {
                    addMessage(`‚ùå Erreur : ${data.error}<br><br>Recommen√ßons. Quel est votre email ?`);
                    step = 'email';
                    config = {};
                }
            } catch (error) {
                hideTyping();
                addMessage(`‚ùå Erreur de connexion. V√©rifiez que le serveur est lanc√©.`);
            }
        }

        async function handleCommand(message) {
            const lower = message.toLowerCase();

            if (lower.includes('envoyer') && lower.includes('test')) {
                showTyping();
                try {
                    const response = await fetch('/api/envoyer-email', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            master_password: 'SESSION_STORED',
                            email_destinataire: config.email,
                            sujet: 'Test Agent Email',
                            message: 'F√©licitations ! Votre agent email fonctionne parfaitement.'
                        })
                    });

                    const data = await response.json();
                    hideTyping();

                    if (data.success) {
                        addMessage(`‚úÖ Email de test envoy√© √† ${config.email} !<br><br>V√©rifiez votre bo√Æte de r√©ception.`);
                    } else {
                        addMessage(`‚ùå Erreur : ${data.error}`);
                    }
                } catch (error) {
                    hideTyping();
                    addMessage(`‚ùå Erreur d'envoi.`);
                }
            }
            else if (lower.includes('envoyer')) {
                addMessage(`Pour envoyer un email, donnez-moi :<br>
                    1Ô∏è‚É£ L'email du destinataire<br>
                    2Ô∏è‚É£ Le sujet<br>
                    3Ô∏è‚É£ Le message<br><br>
                    Format : destinataire@email.com | Sujet | Message`);
                step = 'compose';
            }
            else if (lower.includes('aide')) {
                addMessage(`ü§ñ <b>Commandes disponibles :</b><br><br>
                    ‚Ä¢ "Envoyer un email" - Composer un email<br>
                    ‚Ä¢ "Envoyer un test" - Tester l'envoi<br>
                    ‚Ä¢ "Aide" - Afficher cette aide<br><br>
                    Que voulez-vous faire ?`);
            }
            else if (step === 'compose' && message.includes('|')) {
                const parts = message.split('|').map(p => p.trim());
                if (parts.length === 3) {
                    showTyping();
                    try {
                        const response = await fetch('/api/envoyer-email', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                master_password: 'SESSION_STORED',
                                email_destinataire: parts[0],
                                sujet: parts[1],
                                message: parts[2]
                            })
                        });

                        const data = await response.json();
                        hideTyping();

                        if (data.success) {
                            addMessage(`‚úÖ Email envoy√© √† ${parts[0]} !`);
                            step = 'ready';
                        } else {
                            addMessage(`‚ùå Erreur : ${data.error}`);
                        }
                    } catch (error) {
                        hideTyping();
                        addMessage(`‚ùå Erreur d'envoi.`);
                    }
                } else {
                    addMessage(`‚ùå Format incorrect. Utilisez : email | sujet | message`);
                }
            }
            else {
                addMessage(`Je n'ai pas compris. Tapez "Aide" pour voir les commandes disponibles.`);
            }
        }

        function quickAction(action) {
            document.getElementById('userInput').value = action;
            sendMessage();
        }

        async function uploadAudio(input) {
            if (!input.files || !input.files[0]) return;
            
            const file = input.files[0];
            addMessage(`üé§ Audio re√ßu : ${file.name}`, true);
            
            showTyping();
            const formData = new FormData();
            formData.append('audio', file);
            formData.append('master_password', 'SESSION_STORED');
            formData.append('type_analyse', 'email');
            
            try {
                const response = await fetch('/api/analyser-audio', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                hideTyping();
                
                if (data.success) {
                    addMessage(`üé§ <b>Transcription :</b><br>${data.transcription}<br><br>üìß <b>Email g√©n√©r√© :</b><br>${data.analyse.replace(/\n/g, '<br>')}`);
                } else {
                    addMessage(`‚ùå Erreur : ${data.error}`);
                }
            } catch (error) {
                hideTyping();
                addMessage(`‚ùå Erreur d'analyse audio.`);
            }
            
            input.value = '';
        }
        
        async function uploadDocument(input) {
            if (!input.files || !input.files[0]) return;
            
            const file = input.files[0];
            addMessage(`üìÑ Document re√ßu : ${file.name}`, true);
            
            showTyping();
            const formData = new FormData();
            formData.append('document', file);
            formData.append('master_password', 'SESSION_STORED');
            formData.append('type_analyse', 'email');
            
            try {
                const response = await fetch('/api/analyser-document', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                hideTyping();
                
                if (data.success) {
                    addMessage(`üìÑ <b>Contenu extrait :</b><br>${data.contenu}<br><br>üìß <b>Email g√©n√©r√© :</b><br>${data.analyse.replace(/\n/g, '<br>')}`);
                } else {
                    addMessage(`‚ùå Erreur : ${data.error}`);
                }
            } catch (error) {
                hideTyping();
                addMessage(`‚ùå Erreur d'analyse document.`);
            }
            
            input.value = '';
        }
        
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        
        async function toggleRecording() {
            const micBtn = document.getElementById('micBtn');
            
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    
                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };
                    
                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        await processVoiceInput(audioBlob);
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    mediaRecorder.start();
                    isRecording = true;
                    micBtn.style.background = '#ef4444';
                    micBtn.textContent = '‚èπÔ∏è';
                    addMessage('üé§ Enregistrement en cours...', false);
                } catch (error) {
                    addMessage('‚ùå Erreur micro : ' + error.message);
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;
                micBtn.style.background = '#10b981';
                micBtn.textContent = 'üé§';
            }
        }
        
        async function processVoiceInput(audioBlob) {
            showTyping();
            
            const formData = new FormData();
            formData.append('audio', audioBlob, 'voice.webm');
            formData.append('master_password', 'SESSION_STORED');
            
            try {
                const response = await fetch('/api/speech-to-text', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                hideTyping();
                
                if (data.success) {
                    document.getElementById('userInput').value = data.texte;
                    addMessage(data.texte, true);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    await handleCommand(data.texte);
                } else {
                    addMessage('‚ùå Erreur transcription : ' + data.error);
                }
            } catch (error) {
                hideTyping();
                addMessage('‚ùå Erreur de connexion');
            }
        }
        
        // Focus automatique
        document.getElementById('userInput').focus();
    </script>
</body>
</html>
